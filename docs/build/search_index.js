var documenterSearchIndex = {"docs":
[{"location":"index.html#GraphPartitioning.jl-Documentation","page":"Home","title":"GraphPartitioning.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"GraphPartitioning.jl is a toolbox for graph partitioning algorithms in Julia. It provides a framework to compare, benchmark, and analyze various graph partitioning techniques. The framework supports both non-recursive and recursive methods with geometric information, like coordinate and inertial bisection, as well as methods without geometric information, such as spectral bisection. It makes it easy to evaluate and compare the outputs of different methods, helping users understand their trade-offs and applications.","category":"page"},{"location":"index.html#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install the package from GitHub and add it to your working environment, follow these steps:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Add the GraphPartitioning.jl to you project using the Julia command:\nusing Pkg\nPkg.add(url=\"https://github.com/lechekhabm/GraphPartitioning.jl\")\nNote: If you have an SSH key set up with GitHub, you can install the package using SSH:\nPkg.add(url=\"https://<YOUR_GITHUB_TOKEN>@github.com/lechekhabm/GraphPartitioning.jl.git\")\nReplace <YOUR_GITHUB_TOKEN> with a valid token that has repository read access.\nBasic Example:\nusing GraphPartitioning\nA, coords = GraphPartitioning.build_adjacency(\"network\")\np = GraphPartitioning.part_spectral(A)\nGraphPartitioning.draw_graph(A, coords, p, file_name=\"test.png\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For further details on the package and its functions, see Paper.","category":"page"},{"location":"index.html#Prerequisites-and-Dependencies","page":"Home","title":"Prerequisites and Dependencies","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package will automatically install the following dependencies: Arpack, CairoMakie, Colors, Graphs, LinearAlgebra, Metis, SparseArrays, and Statistics.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For additional usability, you may need the following packages: DelimitedFiles, MAT, Plots, and PrettyTables.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Refer to the source code and Project.toml files within the examples/ directory for further details about dependencies and configurations. Additional explanations are provided later in this document.","category":"page"},{"location":"index.html#Running-Examples","page":"Home","title":"Running Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package includes example scripts in the GraphPartitioning/examples/ directory. These scripts demonstrate how to use the package to benchmark and compare different graph partitioning methods.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To run these examples you need to clone the repo using the command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"git clone https://github.com/lechekhabm/GraphPartitioning.jl","category":"page"},{"location":"index.html#Quick-Start-Example","page":"Home","title":"Quick Start Example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using GraphPartitioning\n\nA, coords = GraphPartitioning.build_adjacency(\"network\")\np = GraphPartitioning.part_spectral(A)\nGraphPartitioning.draw_graph(A, coords, p, file_name=\"test.png\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A simple example demonstrating the usage of GraphPartitioning.jl is available in this Google Colab notebook: Open in Colab.","category":"page"},{"location":"index.html#Example-1:-Comparing-Partitioning-Methods","page":"Home","title":"Example 1: Comparing Partitioning Methods","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Script: GraphPartitioning.jl/examples/ex1.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This example compares different graph partitioning methods, including:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Coordinate Bisection\nInertial Bisection\nSpectral Bisection\nBisection using METIS","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The script evaluates these methods on a series of different graphs, providing insights into their performance and effectiveness.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<!-- 2x2 Grid for Airfoil1 Examples -->\n<table style=\"width:100%; border-collapse: collapse;\">\n  <tr>\n    <!-- Coordinate Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_coordinate.png?raw=true\" alt=\"Coordinate Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Coordinate Bisection</em></p>\n    </td>\n    <!-- Inertial Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_inertial.png?raw=true\" alt=\"Inertial Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Inertial Bisection</em></p>\n    </td>\n  </tr>\n  <tr>\n    <!-- Spectral Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_spectral.png?raw=true\" alt=\"Spectral Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Spectral Bisection</em></p>\n    </td>\n    <!-- METIS Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_metis.png?raw=true\" alt=\"METIS Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>METIS</em></p>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"index.html#How-to-Run-Example-1","page":"Home","title":"How to Run Example 1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Navigate to the examples directory:\ncd GraphPartitioning.jl/examples\nRun the example script in the Julia or directly from the terminal:\njulia ex1.jl","category":"page"},{"location":"index.html#Example-2:-Recursive-Bisection","page":"Home","title":"Example 2: Recursive Bisection","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Script: GraphPartitioning.jl/examples/ex2.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This example demonstrates recursive bisection using different methods, including:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Coordinate Bisection\nInertial Bisection\nSpectral Bisection\nRecursive Bisection using METIS K-way","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table style=\"width:100%; border-collapse: collapse;\">\n  <tr>\n    <!-- Recursive Coordinate Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_coordinate.png?raw=true\" alt=\"Recursive Coordinate Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Coordinate Bisection</em></p>\n    </td>\n    <!-- Recursive Inertial Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_inertial.png?raw=true\" alt=\"Recursive Inertial Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Inertial Bisection</em></p>\n    </td>\n  </tr>\n  <tr>\n    <!-- Recursive Spectral Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_spectral.png?raw=true\" alt=\"Recursive Spectral Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Spectral Bisection</em></p>\n    </td>\n    <!-- Recursive METIS Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_metis_rec.png?raw=true\" alt=\"Recursive METIS Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive METIS Bisection (K-way is also available)</em></p>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"index.html#How-to-Run-Example-2","page":"Home","title":"How to Run Example 2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Navigate to the examples directory:\ncd GraphPartitioning.jl/examples\nRun the example script in the Julia or directly from the terminal:\njulia ex2.jl","category":"page"},{"location":"index.html#Future-Work","page":"Home","title":"Future Work","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Support for higher-dimensional graphs and hypergraphs\nAutomated detection of external software\nPerformance optimizations\nSupport for additional partitioning methods\nEnhanced documentation and tutorials\nInteractive visualization","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Please cite XXXX in your publications if it helps your research:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{doi:10.1137/21M1392231,\n author = {Name},\n title = {Tile},\n journal = X},\n volume = {44},\n number = {3},\n pages = {C210-C236},\n year = {2022},\n doi = {10.1137/21M1392231}\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See https://arxiv.org/pdf/XXXX.pdf for an archived version of the article. ","category":"page"},{"location":"index.html#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"NAME NAME (Institute, University)\nMalik Lechekhab (Institute of Computing, Università della Svizzera italiana)\nAryan Eftekhari (Institute of Computing, Università della Svizzera italiana)","category":"page"},{"location":"index.html#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We would like to thank the authors of SGtSNEpi.jl for their work, which served as a reference for the graph plotting function in this project.","category":"page"},{"location":"documentation.html#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation.html#Graph-Construction","page":"Documentation","title":"Graph Construction","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.build_adjacency","category":"page"},{"location":"documentation.html#GraphPartitioning.build_adjacency","page":"Documentation","title":"GraphPartitioning.build_adjacency","text":"build_adjacency(edges::Matrix{Int}, num_nodes::Int)\n\nConstruct the adjacency matrix of a graph from an edge list.\n\nArguments\n\nedges::Matrix: Matrix where each row represents an edge [u, v].\nnum_nodes::Int: Total number of nodes in the graph.\n\nReturns\n\nA symmetric sparse adjacency matrix (SparseMatrixCSC{Int, Int}).\n\nExample\n\njulia> edges = [1 2; 2 3; 3 1]\njulia> A = build_adjacency(edges, 3)\n\n\n\n\n\nbuild_adjacency(type::String)\n\nGenerate a predefined adjacency matrix and corresponding node coordinates.\n\nArguments\n\ntype::String: Type of graph to generate.  \n\"network\": A predefined network structure.  \n\"triangles\": A small triangular mesh structure.\n\nReturns\n\nA::SparseMatrixCSC: The sparse adjacency matrix of the graph.\ncoords::Matrix: Node coordinates for visualization.\n\nExample\n\njulia> A, coords = build_adjacency(\"network\")\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Native-Partitioning-Methods","page":"Documentation","title":"Native Partitioning Methods","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.part_coordinate\nGraphPartitioning.part_inertial\nGraphPartitioning.part_spectral\nGraphPartitioning.part_metis","category":"page"},{"location":"documentation.html#GraphPartitioning.part_coordinate","page":"Documentation","title":"GraphPartitioning.part_coordinate","text":"part_coordinate(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the coordinate method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_coordinate(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.part_inertial","page":"Documentation","title":"GraphPartitioning.part_inertial","text":"part_inertial(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the inertial method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_inertial(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.part_spectral","page":"Documentation","title":"GraphPartitioning.part_spectral","text":"part_spectral(A::SparseMatrixCSC; fiedler::Bool=false)\n\nCompute a bi-partition of the graph A using the spectral method.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\nfiedler::Bool=false: If true, returns the Fiedler vector instead of partition labels.\n\nReturns\n\nA vector of partition labels (1 or 2).\nIf fiedler=true, returns the Fiedler vector.\n\nExample\n\njulia> part_spectral(A)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.part_metis","page":"Documentation","title":"GraphPartitioning.part_metis","text":"part_metis(A::SparseMatrixCSC, k::Int, alg::Symbol)\n\nPartition the graph A into k parts using METIS with the specified algorithm.\n\nArguments\n\nA: Adjacency matrix of the graph.\nk: Number of partitions.\nalg: Partitioning algorithm (:KWAY or :RECURSIVE).\n\nOutput\n\nReturns a vector of partition labels for each node.\n\nExamples\n\njulia> part_metis(A, 2, :RECURSIVE)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Recursive-Bisection","page":"Documentation","title":"Recursive Bisection","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.recursive_bisection","category":"page"},{"location":"documentation.html#GraphPartitioning.recursive_bisection","page":"Documentation","title":"GraphPartitioning.recursive_bisection","text":"recursive_bisection(method::Function, k::Int, A::AbstractSparseMatrix, \n                    coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8)\n\nPartition the graph A into k parts using recursive bisection with the specified partitioning method.\n\nArguments\n\nmethod::Function: Partitioning method to apply at each bisection step (e.g., part_spectral, part_inertial).\nk::Int: Number of partitions (must be a power of 2 or will be rounded up).\nA::AbstractSparseMatrix: Adjacency matrix of the graph.\ncoords::Union{Matrix, Nothing}=nothing: Node coordinates for spatial partitioning (optional).\nminpoints::Int=8: Minimum number of nodes required for further partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> recursive_bisection(part_spectral, 4, A, coords)\n 1\n ⋮\n 4\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Visualization","page":"Documentation","title":"Visualization","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.draw_graph","category":"page"},{"location":"documentation.html#GraphPartitioning.draw_graph","page":"Documentation","title":"GraphPartitioning.draw_graph","text":"draw_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int}; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the partitioned graph A.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\np: Partition labels for each node.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\ndraw_graph(A::SparseMatrixCSC, coords::Matrix; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the graph A without partitioning.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Utility-Function","page":"Documentation","title":"Utility Function","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.count_edge_cut\nGraphPartitioning.compute_partition_balance","category":"page"},{"location":"documentation.html#GraphPartitioning.count_edge_cut","page":"Documentation","title":"GraphPartitioning.count_edge_cut","text":"count_edge_cut(A::AbstractMatrix, p::AbstractVector)\n\nCount the number of edges that cross partitions in the graph A.\n\nArguments\n\nA::AbstractMatrix: Adjacency matrix of the graph.\np::AbstractVector: Partition vector where p[v] represents the partition of vertex v.\n\nReturns\n\nThe number of edges that connect nodes in different partitions.\n\nExample\n\njulia> count_edge_cut(A, p)\n15\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.compute_partition_balance","page":"Documentation","title":"GraphPartitioning.compute_partition_balance","text":"compute_partition_balance(p::AbstractVector) -> Float64\n\nComputes the balance metric of a given graph partitioning.\n\nParameters\n\np::AbstractVector: A vector where p[i] represents the partition index assigned to vertex i.\n\nReturns\n\nFloat64: The balance metric, defined as the ratio of the largest partition size to the ideal partition size. A value close to 1.0 indicates a well-balanced partitioning, while higher values suggest imbalance.\n\nExample\n\n```julia-repl julia> p = [1, 1, 2, 2, 2, 3, 3, 3, 3]  # Example partitioning julia> balance = computepartitionbalance(p) julia> println(balance)  # Output close to 1 for balanced partitions\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Interfacing-with-External-Partitioning-Tools","page":"Documentation","title":"Interfacing with External Partitioning Tools","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"To integrate with graph partitioning tools such as KaHIP, Graclus, and MDC, we provide utility functions for exporting graph structures, executing external commands, and managing dependencies. These functions streamline the workflow, ensuring compatibility with external software while maintaining interoperability with GraphPartitioning.jl.","category":"page"},{"location":"documentation.html#Writing-a-Graph-File-for-Partitioning-Tools","page":"Documentation","title":"Writing a Graph File for Partitioning Tools","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"This function generates a graph file compatible with tools like KaHIP, Graclus, and MDC from a symmetric adjacency matrix. Steps:     1. Extract the number of nodes and edges from the adjacency matrix.     2. Create a temporary file or save it to ./adjacency_lists depending on the temp flag.     3. Write the graph format:         - The first line contains the number of nodes and edges.         - Each subsequent line lists the neighbors of a node.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Usage:     - If temp=true, the file is temporary.     - If temp=false, the file is saved in ./adjacency_lists with a specified prefix.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"function _write_partition_input(A::SparseMatrixCSC; prefix::String=\"graph\", temp::Bool=false)\n    n_nodes = size(A, 1)\n    I, J, _ = findnz(A)\n    n_edges = div(length(I), 2)\n\n    if temp\n        mktemp() do file, _\n            write(file, \"$n_nodes $n_edges\\n\")\n\n            for i in 1:n_nodes  \n                neighbors = J[findall(==(i), I)]\n                write(file, join(neighbors, \" \") * \"\\n\")\n            end\n\n            return file\n        end\n    else\n        dir = \"./adjacency_lists\"\n        mkpath(dir)\n        file_path = joinpath(dir, \"$prefix.graph\")\n\n        open(file_path, \"w\") do file\n            write(file, \"$n_nodes $n_edges\\n\")\n            for i in 1:n_nodes\n                neighbors = J[findall(==(i), I)]\n                write(file, join(neighbors, \" \") * \"\\n\")\n            end\n        end\n\n        return file_path\n    end\nend","category":"page"},{"location":"documentation.html#Running-an-External-Command-and-Capturing-Output","page":"Documentation","title":"Running an External Command and Capturing Output","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"This function runs a shell command and captures both stdout and stderr. Steps:","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"1. Execute the command asynchronously.\n2. Capture stdout and stderr into separate tasks.\n3. Wait for the process to finish and return the outputs.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"function _run_cmd(cmd::Cmd)\n\tout = Pipe()\n\terr = Pipe()\n\n\tprocess = run(pipeline(cmd, stdout=out, stderr=err), wait=false)\n\n\tclose(out.in)\n\tclose(err.in)\n\n\tstdout_task = @async String(read(out))\n\tstderr_task = @async String(read(err))\n\n\twait(process)\n\n\treturn (\n\t\tstdout = fetch(stdout_task),\n\t\tstderr = fetch(stderr_task),\n\t\tcode = process.exitcode\n\t)\nend","category":"page"},{"location":"documentation.html#Retrieving-and-Validating-an-Executable-Path","page":"Documentation","title":"Retrieving and Validating an Executable Path","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"This function retrieves an external executable's path from an environment variable and ensures it exists. Steps:","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"1. Check if the environment variable is set.\n2. Retrieve the executable path.\n3. Verify that the file exists; otherwise, throw an error.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"function _get_executable(exec_name::String)\n    if !haskey(ENV, exec_name)\n        error(\"❌ Environment variable $exec_name is not set. Please define it with the path to the executable.\")\n    end\n\n    exec_path = ENV[exec_name]\n\n    # Check if the file exists\n    if !isfile(exec_path)\n        error(\"❌ Executable '$exec_path' not found. Please check the $exec_name environment variable.\")\n    end\n\n    return exec_path\nend","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"With these core utility functions in place, we can now implement functions tailored to specific partitioning software.","category":"page"},{"location":"documentation.html#Graclus","page":"Documentation","title":"Graclus","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Graclus is a spectral-based graph clustering and partitioning software.  ","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Installation: You need to manually download and compile Graclus from its official source.  \nEnvironment Variable: Set GRACLUS_PATH to point to the compiled Graclus executable.  ","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"export GRACLUS_PATH=\"/path/to/graclus\"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"function run_graclus(A::SparseMatrixCSC, np::Int; cut_type::String=\"ncut\", local_search::Int=0, dbg::Bool=false)\n\n    mat_path = _write_partition_input(A)\n\n    graclus_exec = _get_executable(\"GRACLUS_PATH\")\n\n\tcmd = `$graclus_exec $mat_path $np -O $cut_type -L $local_search`;\n\n    result = _run_cmd(cmd)\n\t\n    if result.code != 0\n        error(\"❌ Graclus execution failed with error:\\n\" * result.code)\n    end\n\n    partition_file = \"graph.graph\"*\".part.\"*string(np)\n    partitions = Int[]\n\n    try\n        open(partition_file, \"r\") do f\n            for line in eachline(f)\n                push!(partitions, parse(Int, line))\n            end\n        end\n        println(\"✅ Partitions extracted from \", partition_file)\n    catch e\n        error(\"❌ Failed to read partition file '$partition_file': \", e)\n    end\n\n    if dbg\n        println(\"🖥️ Execution Result:\\n\", result.stdout)\n        println(\"📂 Partition File: \", partition_file)\n        println(\"🔢 Partitions: \", partitions)\n        return partitions\n    else\n        # Remove the partition file after reading\n        rm(partition_file, force=true)\n        return partitions\n    end\nend","category":"page"},{"location":"documentation.html#Citation","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Weighted Graph Cuts without Eigenvectors: A Multilevel Approach, I. Dhillon, Y. Guan, and B, Kulis, IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), vol. 29:11, pages 1944-1957, November 2007.\nA Fast Kernel-based Multilevel Algorithm for Graph Clustering, I. Dhillon, Y. Guan, and B, Kulis, Proceedings of The 11th ACM SIGKDD, Chicago, IL, August 21-24, 2005.\nKernel k-means, Spectral Clustering and Normalized Cuts, I. Dhillon, Y. Guan, and B. Kulis, Proceedings of The 10th ACM SIGKDD, Seattle, WA, August 22-25, 2004.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html#KaHIP-(run_kahip)","page":"Documentation","title":"KaHIP (run_kahip)","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"KaHIP (Karlsruhe High-Quality Partitioning) is an efficient graph partitioning tool that supports various heuristics and optimizations.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Installation: You need to download and compile KaHIP from its official source.\nEnvironment Variable: Set KAHIP_PATH to the KaHIP binary.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"export KAHIP_PATH=\"/path/to/kahip\"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"function run_kahip(A::SparseMatrixCSC, np::Int; preconfiguration::String=\"fast\", dbg::Bool=false)\n\n    mat_path = _write_partition_input(A)\n\n    kahip_exec = _get_executable(\"KAHIP_PATH\")\n\n\tcmd = `$kahip_exec $mat_path --k $np --preconfiguration=$preconfiguration`;\n\n    result = _run_cmd(cmd)\n\t\n    if result.code != 0\n        error(\"KaHIP execution failed with error:\\n\" * result.code)\n    end\n\n    partition_file = \"tmppartition\" * string(np)\n    partitions = Int[]\n\n    try\n        open(partition_file, \"r\") do f\n            for line in eachline(f)\n                push!(partitions, parse(Int, line))\n            end\n        end\n        println(\"✅ Partitions extracted from \", partition_file)\n    catch e\n        error(\"❌ Failed to read partition file '$partition_file': \", e)\n    end\n\n    if dbg\n        println(\"🖥️ Execution Result:\\n\", result.stdout)\n        println(\"📂 Partition File: \", partition_file)\n        println(\"🔢 Partitions: \", partitions)\n        return partitions\n    else\n        # Remove the partition file after reading\n        rm(partition_file, force=true)\n        return partitions\n    end\nend","category":"page"},{"location":"documentation.html#Citation-2","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Peter Sanders and Christian Schulz. Engineering Multilevel Graph Partitioning Algorithms. In Proceedings of the 19th European Symposium on Algorithms (ESA'11), volume 6942 of LNCS, pages 469–480. Springer, 2011.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html#Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)","page":"Documentation","title":"Multi-Level Diffusion Clustering (MDC) (run_mdc)","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"MDC is an experimental diffusion-based graph partitioning method.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Installation: You must download, compile, and install MDC following the instructions from official source.\nEnvironment Variable: Set MDC_PATH to point to the MDC executable. It also requires setting LD_LIBRARY_PATH for proper execution.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"export MDC_PATH=\"/path/to/mdc\"\nexport LD_LIBRARY_PATH=\"/path/to/stag/stag-1.3.0/build_dir/stag_lib/\"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"function run_mdc(A::SparseMatrixCSC,\n                np::Int;\n                cut_type::String=\"ncut\",\n                local_search::Int=0,\n                beta_testing::Bool=true,\n                spectral_method::Bool=true,\n                beta_min::Int=0,\n                beta_max::Int=2,\n                dbg::Bool=false)\n\n    mat_path = _write_partition_input(A)\n\n    mdc_exec = _get_executable(\"MDC_PATH\")\n\n\tcmd = `$mdc_exec $mat_path $np -b $beta_testing -s $spectral_method -O $cut_type -y $beta_min -z $beta_max -L $local_search`;\n\n    result = _run_cmd(cmd)\n\t\n    if result.code != 0\n        error(\"❌ MDC execution failed with error:\\n\" * result.code)\n    end\n\n    partition_file = \"graph.graph\"*\".part.\"*string(np)\n    partitions = Int[]\n\n    try\n        open(partition_file, \"r\") do f\n            for line in eachline(f)\n                push!(partitions, parse(Int, line))\n            end\n        end\n        println(\"✅ Partitions extracted from \", partition_file)\n    catch e\n        error(\"❌ Failed to read partition file '$partition_file': \", e)\n    end\n\n    if dbg\n        println(\"🖥️ Execution Result:\\n\", result.stdout)\n        println(\"📂 Partition File: \", partition_file)\n        println(\"🔢 Partitions: \", partitions)\n        return partitions\n    else\n        # Remove the partition file after reading\n        rm(partition_file, force=true)\n        return partitions\n    end\nend","category":"page"},{"location":"documentation.html#Citation-3","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Lechekhab M., Pasadakis D., Schenk O. (forthcoming) Multilevel Diffusion Based Spectral Graph Clustering. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. IEEE. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. Virtual Conference. September 23-27, 2024","category":"page"}]
}
