var documenterSearchIndex = {"docs":
[{"location":"index.html#GraphPartitioning.jl-Documentation","page":"Home","title":"GraphPartitioning.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"GraphPartitioning.jl is a toolbox for graph partitioning algorithms in Julia. It provides a framework to compare, benchmark, and analyze various graph partitioning techniques. The framework supports both non-recursive and recursive methods with geometric information, like coordinate and inertial bisection, as well as methods without geometric information, such as spectral bisection. It makes it easy to evaluate and compare the outputs of different methods, helping users understand their trade-offs and applications.","category":"page"},{"location":"index.html#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install the package from GitHub and add it to your working environment, follow these steps:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Add the GraphPartitioning.jl to you project using the Julia command:\nusing Pkg\nPkg.add(url=\"https://github.com/lechekhabm/GraphPartitioning.jl\")\nNote: If you have an SSH key set up with GitHub, you can install the package using SSH:\nPkg.add(url=\"https://<YOUR_GITHUB_TOKEN>@github.com/lechekhabm/GraphPartitioning.jl.git\")\nReplace <YOUR_GITHUB_TOKEN> with a valid token that has repository read access.\nBasic Example:\nusing GraphPartitioning\nA, coords = GraphPartitioning.build_adjacency(\"network\")\np = GraphPartitioning.part_spectral(A)\nGraphPartitioning.draw_graph(A, coords, p, file_name=\"test.png\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For further details on the package and its functions, see Paper.","category":"page"},{"location":"index.html#Prerequisites-and-Dependencies","page":"Home","title":"Prerequisites and Dependencies","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package will automatically install the following dependencies: Arpack, CairoMakie, Colors, Graphs, LinearAlgebra, Metis, SparseArrays, and Statistics.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For additional usability, you may need the following packages: DelimitedFiles, MAT, Plots, and PrettyTables.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Refer to the source code and Project.toml files within the examples/ directory for further details about dependencies and configurations. Additional explanations are provided later in this document.","category":"page"},{"location":"index.html#Running-Examples","page":"Home","title":"Running Examples","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package includes example scripts in the GraphPartitioning/examples/ directory. These scripts demonstrate how to use the package to benchmark and compare different graph partitioning methods.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To run these examples you need to clone the repo using the command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"git clone https://github.com/lechekhabm/GraphPartitioning.jl","category":"page"},{"location":"index.html#Quick-Start-Example","page":"Home","title":"Quick Start Example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using GraphPartitioning\n\nA, coords = GraphPartitioning.build_adjacency(\"network\")\np = GraphPartitioning.part_spectral(A)\nGraphPartitioning.draw_graph(A, coords, p, file_name=\"test.png\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A simple example demonstrating the usage of GraphPartitioning.jl is available in this Google Colab notebook: Open in Colab.","category":"page"},{"location":"index.html#Example-1:-Comparing-Partitioning-Methods","page":"Home","title":"Example 1: Comparing Partitioning Methods","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Script: GraphPartitioning.jl/examples/ex1.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This example compares different graph partitioning methods, including:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Coordinate Bisection\nInertial Bisection\nSpectral Bisection\nBisection using METIS","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The script evaluates these methods on a series of different graphs, providing insights into their performance and effectiveness.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<!-- 2x2 Grid for Airfoil1 Examples -->\n<table style=\"width:100%; border-collapse: collapse;\">\n  <tr>\n    <!-- Coordinate Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_coordinate.png?raw=true\" alt=\"Coordinate Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Coordinate Bisection</em></p>\n    </td>\n    <!-- Inertial Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_inertial.png?raw=true\" alt=\"Inertial Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Inertial Bisection</em></p>\n    </td>\n  </tr>\n  <tr>\n    <!-- Spectral Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_spectral.png?raw=true\" alt=\"Spectral Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>Spectral Bisection</em></p>\n    </td>\n    <!-- METIS Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 0;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex1_airfoil1_metis.png?raw=true\" alt=\"METIS Bisection\" style=\"width:100%; margin:0; padding:0;\">\n      <p style=\"margin: 0; padding: 0;\"><em>METIS</em></p>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"index.html#How-to-Run-Example-1","page":"Home","title":"How to Run Example 1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Navigate to the examples directory:\ncd GraphPartitioning.jl/examples\nRun the example script in the Julia or directly from the terminal:\njulia ex1.jl","category":"page"},{"location":"index.html#Example-2:-Recursive-Bisection","page":"Home","title":"Example 2: Recursive Bisection","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Script: GraphPartitioning.jl/examples/ex2.jl","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This example demonstrates recursive bisection using different methods, including:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Coordinate Bisection\nInertial Bisection\nSpectral Bisection\nRecursive Bisection using METIS K-way","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"<table style=\"width:100%; border-collapse: collapse;\">\n  <tr>\n    <!-- Recursive Coordinate Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_coordinate.png?raw=true\" alt=\"Recursive Coordinate Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Coordinate Bisection</em></p>\n    </td>\n    <!-- Recursive Inertial Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_inertial.png?raw=true\" alt=\"Recursive Inertial Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Inertial Bisection</em></p>\n    </td>\n  </tr>\n  <tr>\n    <!-- Recursive Spectral Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_spectral.png?raw=true\" alt=\"Recursive Spectral Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive Spectral Bisection</em></p>\n    </td>\n    <!-- Recursive METIS Bisection -->\n    <td style=\"width:50%; text-align: center; padding: 10px;\">\n      <img src=\"https://github.com/lechekhabm/GraphPartitioning.jl/blob/main/examples/ex2_Swiss_graph_metis_rec.png?raw=true\" alt=\"Recursive METIS Bisection\" style=\"width:100%;\">\n      <p style=\"font-size: 12px;\"><em>Recursive METIS Bisection (K-way is also available)</em></p>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"index.html#How-to-Run-Example-2","page":"Home","title":"How to Run Example 2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Navigate to the examples directory:\ncd GraphPartitioning.jl/examples\nRun the example script in the Julia or directly from the terminal:\njulia ex2.jl","category":"page"},{"location":"index.html#Future-Work","page":"Home","title":"Future Work","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Support for higher-dimensional graphs and hypergraphs\nAutomated detection of external software\nPerformance optimizations\nSupport for additional partitioning methods\nEnhanced documentation and tutorials\nInteractive visualization","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Please cite XXXX in your publications if it helps your research:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@article{doi:10.1137/21M1392231,\n author = {Name},\n title = {Tile},\n journal = X},\n volume = {44},\n number = {3},\n pages = {C210-C236},\n year = {2022},\n doi = {10.1137/21M1392231}\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See https://arxiv.org/pdf/XXXX.pdf for an archived version of the article. ","category":"page"},{"location":"index.html#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"NAME NAME (Institute, University)\nMalik Lechekhab (Institute of Computing, Università della Svizzera italiana)\nAryan Eftekhari (Institute of Computing, Università della Svizzera italiana)","category":"page"},{"location":"index.html#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We would like to thank the authors of SGtSNEpi.jl for their work, which served as a reference for the graph plotting function in this project.","category":"page"},{"location":"documentation.html#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"documentation.html#Graph-Construction","page":"Documentation","title":"Graph Construction","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.build_adjacency","category":"page"},{"location":"documentation.html#GraphPartitioning.build_adjacency","page":"Documentation","title":"GraphPartitioning.build_adjacency","text":"build_adjacency(edges::Matrix{Int}, num_nodes::Int)\n\nConstruct the adjacency matrix of a graph from an edge list.\n\nArguments\n\nedges::Matrix: Matrix where each row represents an edge [u, v].\nnum_nodes::Int: Total number of nodes in the graph.\n\nReturns\n\nA symmetric sparse adjacency matrix (SparseMatrixCSC{Int, Int}).\n\nExample\n\njulia> edges = [1 2; 2 3; 3 1]\njulia> A = build_adjacency(edges, 3)\n\n\n\n\n\nbuild_adjacency(type::String)\n\nGenerate a predefined adjacency matrix and corresponding node coordinates.\n\nArguments\n\ntype::String: Type of graph to generate.  \n\"network\": A predefined network structure.  \n\"triangles\": A small triangular mesh structure.\n\nReturns\n\nA::SparseMatrixCSC: The sparse adjacency matrix of the graph.\ncoords::Matrix: Node coordinates for visualization.\n\nExample\n\njulia> A, coords = build_adjacency(\"network\")\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Native-Partitioning-Methods","page":"Documentation","title":"Native Partitioning Methods","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.part_coordinate\nGraphPartitioning.part_inertial\nGraphPartitioning.part_spectral\nGraphPartitioning.part_metis","category":"page"},{"location":"documentation.html#GraphPartitioning.part_coordinate","page":"Documentation","title":"GraphPartitioning.part_coordinate","text":"part_coordinate(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the coordinate method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_coordinate(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.part_inertial","page":"Documentation","title":"GraphPartitioning.part_inertial","text":"part_inertial(A::SparseMatrixCSC, coords::Matrix)\n\nCompute a bi-partition of the graph A using the inertial method based on coords.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\ncoords::Matrix: Node coordinates used for partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> part_inertial(A, coords)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.part_spectral","page":"Documentation","title":"GraphPartitioning.part_spectral","text":"part_spectral(A::SparseMatrixCSC; fiedler::Bool=false)\n\nCompute a bi-partition of the graph A using the spectral method.\n\nArguments\n\nA::SparseMatrixCSC: Adjacency matrix of the graph.\nfiedler::Bool=false: If true, returns the Fiedler vector instead of partition labels.\n\nReturns\n\nA vector of partition labels (1 or 2).\nIf fiedler=true, returns the Fiedler vector.\n\nExample\n\njulia> part_spectral(A)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#GraphPartitioning.part_metis","page":"Documentation","title":"GraphPartitioning.part_metis","text":"part_metis(A::SparseMatrixCSC, k::Int, alg::Symbol)\n\nPartition the graph A into k parts using METIS with the specified algorithm.\n\nArguments\n\nA: Adjacency matrix of the graph.\nk: Number of partitions.\nalg: Partitioning algorithm (:KWAY or :RECURSIVE).\n\nOutput\n\nReturns a vector of partition labels for each node.\n\nExamples\n\njulia> part_metis(A, 2, :RECURSIVE)\n 1\n ⋮\n 2\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#External-Partitioning-Methods","page":"Documentation","title":"External Partitioning Methods","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"The following functions interface with external graph partitioning software and require that the corresponding tools be installed on your system. Additionally, you must ensure that the environment variables for these executables are correctly set before running the functions.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html#Graclus-(run_graclus)","page":"Documentation","title":"Graclus (run_graclus)","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Graclus is a spectral-based graph clustering and partitioning software.  ","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Installation: You need to manually download and compile Graclus from its official source.  \nEnvironment Variable: Set GRACLUS_PATH to point to the compiled Graclus executable.  ","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"export GRACLUS_PATH=\"/path/to/graclus\"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.run_graclus","category":"page"},{"location":"documentation.html#GraphPartitioning.run_graclus","page":"Documentation","title":"GraphPartitioning.run_graclus","text":"run_graclus(A::SparseMatrixCSC, np::Int, cut_type::String=\"ncut\", local_search::Int=0, dbg::Bool=false)\n\nPartition the graph A into np parts using Graclus.\n\nArguments\n\nA: Adjacency matrix (SparseMatrixCSC).\nnp: Number of partitions.\ncut_type: Partitioning objective (\"ncut\" or \"rassoc\", default: \"ncut\").\nlocal_search: Local search level (default: 0).\ndbg: Enable debug output (default: false).\n\nReturns\n\npartitions::Vector: Partitioning results if dbg = false.\n\nOr a tuple if dbg = true:\n\nstdout::String: Command output.\npartitions::Vector: Partitioning results.\npartition_file::String: Output file path.\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Citation","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Weighted Graph Cuts without Eigenvectors: A Multilevel Approach, I. Dhillon, Y. Guan, and B, Kulis, IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), vol. 29:11, pages 1944-1957, November 2007.\nA Fast Kernel-based Multilevel Algorithm for Graph Clustering, I. Dhillon, Y. Guan, and B, Kulis, Proceedings of The 11th ACM SIGKDD, Chicago, IL, August 21-24, 2005.\nKernel k-means, Spectral Clustering and Normalized Cuts, I. Dhillon, Y. Guan, and B. Kulis, Proceedings of The 10th ACM SIGKDD, Seattle, WA, August 22-25, 2004.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html#KaHIP-(run_kahip)","page":"Documentation","title":"KaHIP (run_kahip)","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"KaHIP (Karlsruhe High-Quality Partitioning) is an efficient graph partitioning tool that supports various heuristics and optimizations.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Installation: You need to download and compile KaHIP from its official source.\nEnvironment Variable: Set KAHIP_PATH to the KaHIP binary.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"export KAHIP_PATH=\"/path/to/kahip\"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.run_kahip","category":"page"},{"location":"documentation.html#GraphPartitioning.run_kahip","page":"Documentation","title":"GraphPartitioning.run_kahip","text":"run_kahip(A::SparseMatrixCSC, np::Int, preconfiguration::String, dbg::Bool=false)\n\nRun KaHIP patitioning on a graph matrix file.\n\nArguments\n\nA: Adjacency matrix of the graph (can be sparse).\nnp: Number of partitions.\npreconfiguration: KaHIP preconfiguration mode.\ndbg: Return KaHIP output and file path if true.\n\nReturns\n\npartitions::Vector: Partitioning results if dbg = false.\n\nOr a tuple if dbg = true:\n\nstdout::String: Command output.\npartitions::Vector: Partitioning results.\npartition_file::String: Output file path.\n\nExample\n\njulia> run_kahip(A, \"./graphs/file.graph\", 4, \"fast\")\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Citation-2","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Peter Sanders and Christian Schulz. Engineering Multilevel Graph Partitioning Algorithms. In Proceedings of the 19th European Symposium on Algorithms (ESA'11), volume 6942 of LNCS, pages 469–480. Springer, 2011.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html#Multi-Level-Diffusion-Clustering-(MDC)-(run_mdc)","page":"Documentation","title":"Multi-Level Diffusion Clustering (MDC) (run_mdc)","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"MDC is a novel diffusion-based graph partitioning method.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Installation: You must download, compile, and install MDC following the instructions from official source.\nEnvironment Variable: Set MDC_PATH to point to the MDC executable. It also requires setting LD_LIBRARY_PATH for proper execution.","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"export MDC_PATH=\"/path/to/mdc\"\nexport LD_LIBRARY_PATH=\"/path/to/stag/stag-1.3.0/build_dir/stag_lib/\"","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.run_mdc","category":"page"},{"location":"documentation.html#GraphPartitioning.run_mdc","page":"Documentation","title":"GraphPartitioning.run_mdc","text":"run_mdc(A::SparseMatrixCSC, np::Int; cut_type::String=\"ncut\", local_search::Int=0, \n        beta_testing::Bool=true, spectral_method::Bool=true, beta_min::Int=0, \n        beta_max::Int=2, dbg::Bool=false)\n\nPartition the graph A into np parts using the MDC algorithm.\n\nArguments\n\nA: Adjacency matrix (SparseMatrixCSC).\nnp: Number of partitions.\ncut_type: Partitioning objective (default: \"ncut\").\nlocal_search: Local refinement level (default: 0).\nbeta_testing: Enable beta parameter tuning (default: true).\nspectral_method: Use spectral partitioning (default: true).\nbeta_min: Minimum beta value (default: 0).\nbeta_max: Maximum beta value (default: 2).\ndbg: Enable debug output (default: false).\n\nReturns\n\npartitions::Vector: Partitioning results if dbg = false.\n\nOr a tuple if dbg = true:\n\nstdout::String: Command output.\npartitions::Vector: Partitioning results.\npartition_file::String: Output file path.\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Citation-3","page":"Documentation","title":"Citation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"Lechekhab M., Pasadakis D., Schenk O. (forthcoming) Multilevel Diffusion Based Spectral Graph Clustering. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. IEEE. 28th Annual IEEE High Performance Extreme Computing Virtual Conference. Virtual Conference. September 23-27, 2024","category":"page"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"documentation.html#Recursive-Bisection","page":"Documentation","title":"Recursive Bisection","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.recursive_bisection","category":"page"},{"location":"documentation.html#GraphPartitioning.recursive_bisection","page":"Documentation","title":"GraphPartitioning.recursive_bisection","text":"recursive_bisection(method::Function, k::Int, A::AbstractSparseMatrix, \n                    coords::Union{Matrix, Nothing}=nothing, minpoints::Int=8)\n\nPartition the graph A into k parts using recursive bisection with the specified partitioning method.\n\nArguments\n\nmethod::Function: Partitioning method to apply at each bisection step (e.g., part_spectral, part_inertial).\nk::Int: Number of partitions (must be a power of 2 or will be rounded up).\nA::AbstractSparseMatrix: Adjacency matrix of the graph.\ncoords::Union{Matrix, Nothing}=nothing: Node coordinates for spatial partitioning (optional).\nminpoints::Int=8: Minimum number of nodes required for further partitioning.\n\nReturns\n\nA vector of partition labels for each node.\n\nExample\n\njulia> recursive_bisection(part_spectral, 4, A, coords)\n 1\n ⋮\n 4\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Visualization","page":"Documentation","title":"Visualization","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.draw_graph","category":"page"},{"location":"documentation.html#GraphPartitioning.draw_graph","page":"Documentation","title":"GraphPartitioning.draw_graph","text":"draw_graph(A::SparseMatrixCSC, coords::Matrix, p::Vector{Int}; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the partitioned graph A.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\np: Partition labels for each node.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\ndraw_graph(A::SparseMatrixCSC, coords::Matrix; file_name::Union{String, Nothing}=nothing)\n\nDraw and optionally save a visualization of the graph A without partitioning.\n\nArguments\n\nA: Adjacency matrix of the graph.\ncoords: Node coordinates for plotting.\nfile_name (optional): If provided, saves the figure to the specified file.\n\nOutput\n\nReturns the generated figure.\nSaves the figure if file_name is specified.\n\n\n\n\n\n","category":"function"},{"location":"documentation.html#Utility-Function","page":"Documentation","title":"Utility Function","text":"","category":"section"},{"location":"documentation.html","page":"Documentation","title":"Documentation","text":"GraphPartitioning.count_edge_cut","category":"page"},{"location":"documentation.html#GraphPartitioning.count_edge_cut","page":"Documentation","title":"GraphPartitioning.count_edge_cut","text":"count_edge_cut(A::AbstractMatrix, p::AbstractVector)\n\nCount the number of edges that cross partitions in the graph A.\n\nArguments\n\nA::AbstractMatrix: Adjacency matrix of the graph.\np::AbstractVector: Partition vector where p[v] represents the partition of vertex v.\n\nReturns\n\nThe number of edges that connect nodes in different partitions.\n\nExample\n\njulia> count_edge_cut(A, p)\n15\n\n\n\n\n\n","category":"function"}]
}
