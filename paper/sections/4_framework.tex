%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Framework
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \documentclass[../paper.tex]{subfiles}
% \begin{document}
    % While a variety of algorithms exist for performing graph bisection, as discussed in \Cref{sec:algo},
    % an integrated framework is essential to streamline the entire workflow,
    % from graph creation and algorithm execution to benchmarking and visualization.
\texttt{GraphLab.jl} provides a framework for graph partitioning that consists of the following core modules:
    \begin{enumerate}
        \item \textbf{Graph creation}: Generating graphs with node positions defined by coordinate systems.
        \item \textbf{Graph partitioning}: Implementing the recursive bisection methods detailed in~\Cref{sec:algo}.
        \item \textbf{Benchmarking}: Measuring and comparing algorithm performance according to graph cut criteria.
        \item \textbf{Visualization}: Visualizing graphs and their partitions to facilitate analysis and comparison.
        % \item \textbf{Integration}: Enabling interoperability with existing graph partitioning tools and libraries.
    \end{enumerate}
    % By consolidating these elements, \texttt{GraphLab.jl} aims to offer a seamless and reproducible workflow for studying and applying graph bisection techniques.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Graph creation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
    % \subsection{Graph creation}
    % \label{subsec:graph_creat}
    % The first step in the framework involves preparing the graph for bisection.
    % This process begins with the input of a file containing either the graph's adjacency matrix, vertex coordinates, or both. Supported format includes \texttt{.csv}, which typically stores coordinate data, and \texttt{.mat},
    % which is a MATLAB format commonly used to numerical data storage. The procedure is outlined as follows:
    % \begin{enumerate}
    %     \item \textbf{Input file parsing}: The user provides a filename (e.g., \texttt{airfoil1} or \texttt{mesh3e1}) containing the graph data. If the file is in
    %     \texttt{.csv} format, it is assumed to store a list of vertex coordinates. If the file is in
    %     \texttt{.mat} format, it may contain multiple variables, typically including
    %     the adjacency matrix $\mathbf{A}$ and the coordinates.
    
    %     \item \textbf{File type detection}: The program identifies the file format and 
    %     extracts the relevant information; if an adjacency matrix is present, it is loaded directly; if only the coordinates are provided, further processing is required to construct the adjacency matrix.
    
    %     \item \textbf{Adjacency matrix construction}: If $\mathbf{A}$ is not provided explicitly, it is generated from the vertex coordinates based on spatial proximity or another specified rule, such as $k$-nearest neighbors.
    
    %     \item \textbf{Symmetry check and symmetrization}: Since the framework assumes undirected graphs, the adjacency matrix is checked for symmetry. If $\mathbf{A}$ is not symmetric, it is symmetrized using
    %     \begin{equation}
    %         \mathbf{A}_{\mathrm{sym}} = \frac{\mathbf{A}+\mathbf{A}^T}{2}
    %     \end{equation}
    %     This ensures compatibility with the bisection algorithms presented in \ref{sec:algo}.
    
    %     \item \textbf{Output}: The procedure returns the adjacency matrix $\mathbf{A}$ and a vertex
    %     coordinates (if available). These components serve as inputs for subsequent steps, such
    %     as graph visualization and partitioning.
    % \end{enumerate}
    % This process leverages the functionalities of the \texttt{DelimitedFiles.jl}\footnote{\url{https://docs.julialang.org/en/v1/stdlib/DelimitedFiles/}} and \texttt{MAT.jl}\footnote{\url{https://github.com/JuliaIO/MAT.jl}} packages to handle file parsing and data extraction.

    \subsection{Graph creation}
    \label{subsec:graph_creat}
    
    Graphs can either be synthetically generated or loaded from external files.
    Synthetic graphs are typically generated as $n \times m$ grids with a rotation of $\theta$ radians.
    % using functions like \texttt{GraphLab.grid\_graph(\(n\), \(m\), \(\theta\))}, which creates a $n \times m$ grid rotated by \(\theta\) radians.
    Alternatively, users can upload a \texttt{.mat} file with an adjacency matrix and optional coordinates, or a \texttt{.csv} file with coordinates only, from which the adjacency matrix is constructed using $k$-nearest neighbors using \texttt{NearestNeighbors.jl}\footnote{\url{https://github.com/KristofferC/NearestNeighbors.jl}}, with a default number of 5 neighbors.
    % Alternatively, users may upload a \texttt{.mat} or \texttt{.csv} file. If a \texttt{.mat} file is provided, it is expected to contain an adjacency matrix \(\mathbf{A}\) and, optionally, vertex coordinates. A \texttt{.csv} file is assumed to provide only the coordinates, in which case the adjacency matrix can be built using $k$-nearest neighbors.
    % In all cases, the graph is assumed to be undirected; if \(\mathbf{A}\) is not symmetric, it can be symmetrized:
    % \begin{equation}
    %     \mathbf{A}_{\mathrm{sym}} = \frac{\mathbf{A} + \mathbf{A}^\top}{2}
    % \end{equation}
    The file parsing and data loading are handled by the external packages \texttt{MAT.jl}\footnote{\url{https://github.com/JuliaIO/MAT.jl}} and \texttt{CSV.jl}\footnote{\url{https://github.com/JuliaData/CSV.jl}}
    
    % This preprocessing yields the adjacency matrix and coordinates needed for subsequent partitioning and visualization steps. File parsing and data loading rely on \texttt{MAT.jl}\footnote{\url{https://github.com/JuliaIO/MAT.jl}} and \texttt{DelimitedFiles.jl}\footnote{\url{https://docs.julialang.org/en/v1/stdlib/DelimitedFiles/}}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Benchmarking
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \subsection{Benchmarking}
    % \label{subsec:bench}
    % The framework includes two benchmarking procedures to evaluate the performance of the implemented bisection methods, focusing on both edge cut and partition balance ratio as key evaluation metrics. Additional metrics can be
    % incorporated in future analyses to provide a more comprehensive assessment.
    % \begin{enumerate}
    %     \item \textbf{Bisection method comparison}: This benchmark compares different bisection methods across various input meshes. The partitioning quality is assessed using both edge cut and partition balance ratio as performance metrics.
    %     \item \textbf{Recursive bisection comparison}: This benchmark assesses recursive bisection strategies applied to different meshes and partitioning methods. The graph is partitioning into $p=8$ and
    %     $p=16$ subdomains, and both edge cut and balance ratio are measured to assess the efficiency of the recursive process. 
    % \end{enumerate}
    
    % The results are presented in tables generated using \texttt{PrettyTables.jl}\footnote{\url{https://ronisbr.github.io/PrettyTables.jl/stable/}} for structured and clear visualization. While
    % edge cut and balance ratio serve as primary evaluation criteria, the framework is designed to accommodate additional metrics in future extensions, such as partition balance and computational efficiency.

    \subsection{Benchmarking}
    \label{subsec:bench}
    
    The framework includes two example scripts, provided in the \texttt{examples} directory of the \texttt{GraphLab.jl} package, that benchmark the implemented graph partitioning methods in terms of edge, ratio, and normalized cut, and in terms of node balance ratio.
    % The edge cut is defined as the number of edges crossing between partitions, while the balance ratio measures how evenly the graph is divided.
    % The edge cut is defined as the number of edges that cross between partitions,
    % $\operatorname{cut}(\mathcal{V}_1, \mathcal{V}_2) = |\{(i, j) \mid \mathbf{A}_{ij} \neq 0, i \in \mathcal{V}_1, j \in \mathcal{V}_2\}|$.
    %  Related objective functions include the Normalized Cut, $\operatorname{NCut} = \operatorname{cut}$
    % The balance ratio quantifies vertices are distributed among partitions. Let $n$ be the total number of vertices, $k$ the number of partitions, and $|\mathcal{V}_i|$ the size of partition $\mathcal{V}_i$. The ideal partition size is $n/k$, and the balance ratio is defined as $\operatorname{bal} = \frac{\max_i |\mathcal{V}_i|}{n/k}$. A perfectly balanced partition yields $\operatorname{bal} = 1$, while larger values indicate increasing imbalance.
    The edge cut measures the number of edges crossing between partitions. For a $k$-way partitiong $\mathcal{V}_1, \dots, \mathcal{V}_k$, it is defined as
    $\operatorname{cut}(\mathcal{V}_1,\dots,\mathcal{V}_k)
    = \bigl|\{(u,v)\in E : u\in\mathcal{V}_i, v\in\mathcal{V}_j, i\ne j\}\bigr|$.
    % $\operatorname{cut} = \sum_{i\neq j}|\{(u, v)  \mid u \in \mathcal{V}_i, v\in \mathcal{V}_j\}|$
    The balance ratio quantifies the distribution of vertices among partitions. Let $n$ be the total number of vertices, $k$ the number of partitions, and $|\mathcal{V}_i|$ the size of partition $\mathcal{V}_i$. The ideal partition size is $n/k$, and the node balance ratio is defined as $\operatorname{bal} = \frac{\max_i |\mathcal{V}_i|}{n/k}$. A perfectly balanced partitioning results in $\operatorname{bal} = 1$, while larger values indicate increasing imbalance.
    To evaluate both separation quality and partition balance, two common normalized metrics are used.
    The Normalized Cut is defined as  
    $\operatorname{NCut} = \sum_{i=1}^k \frac{\operatorname{cut}(\mathcal{V}_i,\bar{\mathcal{V}}_i)}{\operatorname{vol}(\mathcal{V}_i)}$,
    where 
    $\operatorname{vol}(\mathcal{V}_i) = \sum_{v\in\mathcal{V}_i} \deg(v)$
    and $\bar{\mathcal{V}}_i$ denotes the complement of $\mathcal{V}_i$ in $\mathcal{V}$, i.e., $\bar{\mathcal{V}}_i = \mathcal{V} \setminus \mathcal{V}_i$.
    The Ratio Cut is defined as $\operatorname{RCut} = \sum_{i=1}^k \frac{\operatorname{cut}(\mathcal{V}_i,\bar{\mathcal{V}}_i)}{|\mathcal{V}_i|}$. Both metrics penalize unbalanced partitions and favor cuts that correspond to sparse inter-partition connections in the graph. The provided benchmarking example scripts are:
   
    
    \begin{enumerate}
        \item \texttt{ex1.jl}: Benchmarks multiple bisection methods across a set of mesh inputs from the university of Florida sparse matrix collection~\cite{10.1145/2049662.2049663}. For each method and mesh, it computes the edge cut, normalized cut, and ratio cut. As shown in \Cref{tab:edgecut-table}, no single bisection strategy is consistently best across all considered meshes.
        % ; the performance varies according to the underlying graph topology.
    
        \item \texttt{ex2.jl}: Benchmarks recursive bisection. The graph is recursively partitioned into $p = 8$ and $p = 16$ subdomains using a given base bisection method. Edge cut and node balance are recorded for each case.
        % Edge cut values are reported in Table~\ref{tab:swiss-combined}.
    \end{enumerate}

    \begin{table*}[t]
        \centering
        \small
        \setlength{\tabcolsep}{5.5pt} 
        \tbl{Edge cuts (EC), normalized cuts (NC), and ratio cuts (RC) for each method and mesh.}{
        \begin{tabular}{l|rrr|rrr|rrr|rrr|rrr|rrr}
        \hline
        \multicolumn{1}{l}{\textbf{Mesh}} &
        \multicolumn{3}{|c}{Coordinate} &
        \multicolumn{3}{|c}{Inertial} &
        \multicolumn{3}{|c}{Random sphere} &
        \multicolumn{3}{|c}{Adaptive SFC} &
        \multicolumn{3}{|c}{Spectral} &
        \multicolumn{3}{|c}{Geo+Spectral}\\
        % \cline{2-4}\cline{5-7}\cline{8-10}\cline{11-13}\cline{14-16}\cline{17-19}
        & \textit{EC} & \textit{NC} & \textit{RC}
        & \textit{EC} & \textit{NC} & \textit{RC}
        & \textit{EC} & \textit{NC} & \textit{RC}
        & \textit{EC} & \textit{NC} & \textit{RC}
        & \textit{EC} & \textit{NC} & \textit{RC}
        & \textit{EC} & \textit{NC} & \textit{RC}\\
        \hline
        \texttt{3elt}             & 172 & 0.03 & 0.15 & 209 & 0.03 & 0.18 & 101 & 0.02 & 0.09 & 224 & 0.03 & 0.19 & 117 & 0.02 & 0.10 & 117 & 0.02 & 0.10 \\
        \texttt{airfoil1}         & 94 & 0.02 & 0.09 & 94 & 0.02 & 0.09 & 93 & 0.02 & 0.09 & 98 & 0.02 & 0.09 & 132 & 0.02 & 0.12 & 132 & 0.02 & 0.12 \\
        \texttt{barth4}           & 206 & 0.02 & 0.14 & 194 & 0.02 & 0.13 & 130 & 0.01 & 0.09 & 208 & 0.02 & 0.14 & 127 & 0.01 & 0.08 & 127 & 0.01 & 0.08 \\
        \texttt{crack}            & 323 & 0.02 & 0.13 & 377 & 0.03 & 0.15 & 274 & 0.02 & 0.11 & 353 & 0.02 & 0.14 & 233 & 0.02 & 0.09 & 233 & 0.02 & 0.09 \\
        \texttt{mesh1e1}          & 18 & 0.24 & 1.50 & 19 & 0.25 & 1.58 & 17 & 0.24 & 1.50 & 18 & 0.24 & 1.50 & 18 & 0.24 & 1.50 & 18 & 0.24 & 1.50 \\
        \texttt{mesh2e1} & 37 & 0.07 & 0.48 & 47 & 0.09 & 0.61 & 35 & 0.07 & 0.46 & 40 & 0.08 & 0.52 & 35 & 0.07 & 0.46 & 35 & 0.07 & 0.46 \\
        \texttt{mesh3e1}          & 17 & 0.05 & 0.24 & 32 & 0.09 & 0.44 & 18 & 0.06 & 0.25 & 21 & 0.06 & 0.29 & 30 & 0.09 & 0.42 & 20 & 0.05 & 0.36 \\
        \texttt{mesh3em5}         & 17 & 0.05 & 0.24 & 32 & 0.09 & 0.44 & 18 & 0.06 & 0.25 & 21 & 0.06 & 0.29 & 18 & 0.05 & 0.25 & 19 & 0.05 & 0.25 \\
        \texttt{netz4504\_dual}   & 25 & 0.04 & 0.16 & 30 & 0.05 & 0.20 & 24 & 0.04 & 0.15 & 25 & 0.04 & 0.16 & 23 & 0.04 & 0.15 & 23 & 0.04 & 0.15 \\
        \texttt{stufe}            & 16 & 0.02 & 0.06 & 16 & 0.02 & 0.06 & 16 & 0.02 & 0.06 & 16 & 0.02 & 0.06 & 16 & 0.02 & 0.06 & 16 & 0.02 & 0.06 \\
        \texttt{ukerbe1}          & 27 & 0.01 & 0.02 & 28 & 0.01 & 0.02 & 37 & 0.01 & 0.02 & 34 & 0.01 & 0.02 & 29 & 0.01 & 0.02 & 28 & 0.01 & 0.02 \\
        % \texttt{3elt}             & 172.0 & 0.025 & 0.146 & 209.0 & 0.03 & 0.177 & 101.0 & 0.015 & 0.089 & 224.0 & 0.033 & 0.19 & 117.0 & 0.017 & 0.099 & 117.0 & 0.017 & 0.099 \\
        % \texttt{airfoil1}         & 94.0 & 0.015 & 0.088 & 94.0 & 0.015 & 0.088 & 93.0 & 0.015 & 0.089 & 98.0 & 0.016 & 0.092 & 132.0 & 0.021 & 0.124 & 132.0 & 0.021 & 0.124 \\
        % \texttt{barth4}           & 206.0 & 0.02 & 0.137 & 194.0 & 0.019 & 0.129 & 130.0 & 0.012 & 0.085 & 208.0 & 0.02 & 0.138 & 127.0 & 0.012 & 0.084 & 127.0 & 0.012 & 0.084 \\
        % \texttt{crack}            & 323.0 & 0.021 & 0.126 & 377.0 & 0.025 & 0.147 & 274.0 & 0.018 & 0.108 & 353.0 & 0.023 & 0.138 & 233.0 & 0.015 & 0.091 & 233.0 & 0.015 & 0.091 \\
        % \texttt{mesh1e1}          & 18.0 & 0.235 & 1.5 & 19.0 & 0.248 & 1.583 & 17.0 & 0.235 & 1.5 & 18.0 & 0.235 & 1.5 & 18.0 & 0.235 & 1.5 & 18.0 & 0.235 & 1.5 \\
        % \texttt{mesh2e1}          mesh2e1.mat & 37.0 & 0.073 & 0.484 & 47.0 & 0.093 & 0.614 & 35.0 & 0.067 & 0.458 & 40.0 & 0.079 & 0.523 & 35.0 & 0.069 & 0.458 & 35.0 & 0.069 & 0.458 \\
        % \texttt{mesh3e1}          & 17.0 & 0.05 & 0.236 & 32.0 & 0.093 & 0.443 & 18.0 & 0.055 & 0.249 & 21.0 & 0.061 & 0.291 & 30.0 & 0.087 & 0.415 & 20.0 & 0.052 & 0.36 \\
        % \texttt{mesh3em5}         & 17.0 & 0.05 & 0.236 & 32.0 & 0.093 & 0.443 & 18.0 & 0.055 & 0.249 & 21.0 & 0.061 & 0.291 & 18.0 & 0.052 & 0.249 & 19.0 & 0.052 & 0.249 \\
        % \texttt{netz4504\_dual}   & 25.0 & 0.043 & 0.163 & 30.0 & 0.051 & 0.195 & 24.0 & 0.039 & 0.15 & 25.0 & 0.043 & 0.163 & 23.0 & 0.039 & 0.15 & 23.0 & 0.039 & 0.15 \\
        % \texttt{stufe}            & 16.0 & 0.017 & 0.062 & 16.0 & 0.017 & 0.062 & 16.0 & 0.017 & 0.062 & 16.0 & 0.017 & 0.062 & 16.0 & 0.017 & 0.062 & 16.0 & 0.017 & 0.062 \\
        % \texttt{ukerbe1}          & 27.0 & 0.007 & 0.018 & 28.0 & 0.007 & 0.019 & 37.0 & 0.007 & 0.024 & 34.0 & 0.009 & 0.023 & 29.0 & 0.007 & 0.019 & 28.0 & 0.007 & 0.019 \\
        
        % \texttt{3elt}             & 172 &&& 209 &&& 94 &&& 224 &&& 117 &&& 117 &&& 90 \\
        % \texttt{airfoil1}         & 94 &&& 94 &&& 93 &&& 98 &&& 132 &&& 132 &&& 73 \\
        % \texttt{barth4}           & 206 &&& 194 &&& 130 &&& 208 &&& 127 &&& 127 &&& 100 \\
        % \texttt{crack}            & 323 &&& 377 &&& 275 &&& 353 &&& 233 &&& 233 &&& 200 \\
        % \texttt{mesh1e1}          & 18 &&& 19 &&& 18 &&& 18 &&& 18 &&& 18 &&& 17 \\
        % \texttt{mesh2e1}          & 37 &&& 47 &&& 36 &&& 40 &&& 35 &&& 35 &&& 34 \\
        % \texttt{mesh3e1}          & 17 &&& 32 &&& 18 &&& 21 &&& 30 &&& 20 &&& 18 \\
        % \texttt{mesh3em5}         & 17 &&& 32 &&& 18 &&& 21 &&& 18 &&& 20 &&& 18 \\
        % \texttt{netz4504\_dual}   & 25 &&& 30 &&& 23 &&& 25 &&& 23 &&& 23 &&& 20 \\
        % \texttt{stufe}            & 16 &&& 16 &&& 16 &&& 16 &&& 16 &&& 16 &&& 17 \\
        % \texttt{ukerbe1}          & 27 &&& 28 &&& 34 &&& 34 &&& 28 &&& 28 &&& 30 \\
        \hline
        \end{tabular}}
        \label{tab:edgecut-table}
    \end{table*}

    % \begin{table}[h]
    %     \tbl{Edge cut values for recursive bisection into 8 and 16 subdomains on \texttt{Swiss\_graph}.}{
    %     \begin{tabular}{|l|c|c|}
    %     \hline
    %     \textbf{Method} & \textbf{8-way} & \textbf{16-way} \\
    %     \hline
    %     Recursive:\texttt{coordinate} & 520 & 858 \\
    %     Recursive:\texttt{inertial}   & 500 & 828 \\
    %     Recursive:\texttt{spectral}   & 459 & 753 \\
    %     \texttt{METIS\_rec}           & 389 & 699 \\
    %     \texttt{METIS\_kway}          & 392 & 693 \\
    %     \hline
    %     \end{tabular}}
    %     \label{tab:swiss-combined}
    % \end{table}
        
    % All results are saved and exported using \texttt{CSV.jl}. While edge cut and balance are the primary metrics, the framework can be extended to track additional criteria such as separator size or runtime.
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Visualization
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Visualization}
    \label{subsec:visu}
    To visualize graph partitions, the adjacency matrix $\mathbf{A}$, the vertex coordinates, and the corresponding partitioning are required.
    \texttt{GraphLab.jl} integrates several Julia packages to support this process.
    Our visualization routine utilizes the edge-drawing logic from the visualization code available in the \texttt{SGtSNEpi.jl} repository~\cite{pitsianis2019sgtsnepi}.
    % \texttt{SGtSNEpi.jl}~\cite{pitsianis2019sgtsnepi} provides a Julia wrapper to \texttt{SG-t-SNE-$\Pi$}, a high-performance software for efficiently embedding large, sparse graphs into low-dimensional space on shared-memory architecture. \texttt{SG-t-SNE-$\Pi$} was demonstrated to enable novel, autonomous embeddings of large, real-world stochastic networks~\cite{Pitsianis2019}.
    % \texttt{SGtSNEpi.jl}~\cite{pitsianis2019sgtsnepi} provides a Julia wrapper to \texttt{SG-t-SNE-$\Pi$}, a high-performance software for embedding large, sparse graphs into low-dimensional space on shared-memory architecture. The current version of \texttt{GraphLab.jl} integrates only the drawing and rendering modules from the wrapper, not its node coordinate-generation pipeline.
    % \texttt{SGtSNEpi.jl}
    % ~\cite{pitsianis2019sgtsnepi} provides a Julia wrapper to \texttt{SG-t-SNE-$\Pi$}, a high-performance software for embedding large, sparse graphs into low-dimensional space on shared-memory architecture. The current version of \texttt{GraphLab.jl} uses \texttt{SGtSNEpi.jl} primarly as a reference for its graph-plotting functionality, integrating and adapting only its drawing and rendering modules.
    \texttt{Graphs.jl}~\cite{Graphs2021} supplies fundamental graph operations and data structures for computations on the partitioned graphs, and
    \texttt{Makie.jl}~\cite{DanischKrumbiegel2021} enables the creation of customizable plots with visually distinct color palettes from \texttt{Colors.jl}~\footnote{\url{https://juliagraphics.github.io/Colors.jl}}.
    

    
    % \begin{itemize}
    %     \item \textbf{\texttt{SGtSNEpi.jl}}: A scalable tools for embedding and plotting large graphs, addressing challenges posed by visualization libraries that struggle with size constraints.
    %     \item \textbf{\texttt{Graphs.jl}}: Provides essential graph operations and data structures.
    %     \item \textbf{\texttt{CairoMakie.jl}}\: Enables the creation of customizable plots suitable for publication.
    %     \item \textbf{\texttt{Colors.jl}}: Manages color palettes for visually distinguishable partitions.
    % \end{itemize}

    Illustrations of selected bipartitioning and recursive bisection results are offered in~\Cref{fig:ex1_results} and~\Cref{fig:ex2_results}, respectively.

    \input{figures/ex1_results}

    \input{figures/ex2_results}
   % \input{figures/visualization_fig}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Integration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \subsection{Integration with external graph partitioning software}
    % \label{subsec:integr}
    % The framework supports interoperability with widely used graph partitioning tools, allowing
    % users to incorporate advanced algorithms alongside the provided methods.
    % We provide guidelines and examples demonstrating how to integrate external software into
    % \texttt{GraphLab.jl}.
    % The proposed integration workflow follows these steps:

    %     \begin{enumerate}
    %         \item \textbf{Graph file generation}: Convert the symmetric adjacency matrix into a format compatible with external tools. The standard format includes:
    %             \begin{itemize}
    %                 \item The first line specifying the number of nodes and edges.
    %                 \item Each subsequent line representing a node, listing its neighbors as space-separated integers.
    %             \end{itemize}
                
    %         \item \textbf{Executable path retrieval and validation}: Retrieve the path of the external partitioning software from environment variables and ensure its existence.
            
    %         \item \textbf{Error handling}: Verify the exit code to detect execution failures or misconfigurations.
            
    %         \item \textbf{Partition file retrieval}: Load the partition file generated by the external software.
            
    %         \item \textbf{Partition assignment}: Parse the output and return the partitions as a vector for further processing within the framework.
    %     \end{enumerate}

    % Notable partitioning software that can be integrated include:

    %     \begin{itemize}
    %         \item \textbf{METIS}: A widely used and robust multilevel recursive partitioning strategy for large graphs and meshes\cite{4302760}. It can be accessed through the \texttt{METIS.jl} package\footnote{\url{https://github.com/KarypisLab/METIS}}, which provides a Julia interface to METIS functionalities.

    %         \item \textbf{KaHIP}: A state-of-the-art graph partitioning framework\footnote{\url{https://github.com/KaHIP/KaHIP}} that employs combinatorial optimizations and iterative refinement techniques to produce high-quality, balanced partitions\cite{DBLP:conf/wea/SandersS13}.

    %         \item \textbf{MDC}: An experimental multilevel diffusion clustering techniques based on \texttt{Graclus}\cite{10.1145/1081870.1081948, 4302760}. It leverages diffusion principles to enhance partitioning flexibility through a tunable diffusion parameter\cite{Lechekhab2024MDC}.
    %     \end{itemize}

    % By providing structured workflows and documentation on integrating these tools, we aim to enable users to leverage diverse partitioning methods within a unified research and experimentation environment. Examples demonstrating practical implementations of these integration are available in the documentation of \texttt{GraphLab.jl}.

    
    % To provide flexibility and access well-established graph partitioning techniques, our framework includes interfaces to several partitining algorithms. These include \texttt{METIS} (via \texttt{METIS.jl}), \texttt{KaHIP}, \texttt{Graclus}, and \texttt{Multilevel Diffusion Clustering} (MDC) implemented in \texttt{C}. Each of these algorithms follows distinct principles and trade-offs, making them suitable of different graph partitiong tasks. The integration is designed to allow users to seamlessly call these external methods from Julia, either through direct packages interfaces or system-level calls.
    
    % \subsubsection{METIS --- Multilevel Recursive Graph Partitioning}
    % \texttt{METIS}\footnote{\url{https://github.com/KarypisLab/METIS}} is a widely used and robust graph partitioning library designed for
    % large-scale applications. It employs a multilevel recursive partitioning strategy that balances
    % computational efficiency and partition quality\cite{4302760}. The algorithm has been extensively used in
    % domains such as scientific computing, high-performance computing, and network analysis.
    % Our framework uses the \texttt{METIS.jl}\footnote{\url{https://github.com/JuliaSparse/Metis.jl}} package, a Julia wrapper around the \texttt{METIS} library that offers direct execution of partitioning routines.
    
    % \subsubsection{KaHIP --- Karlsruhe High-Quality Patritioning}
    % \texttt{KaHIP}\footnote{\url{https://github.com/KaHIP/KaHIP}} is a state-of-the-art graph partitioning framework designed to produce high-quality balanced partitions while minimizing edge cut\cite{DBLP:conf/wea/SandersS13}. Unlike traditional partitioning methods that prioritize speed, \texttt{KaHIP} emphasizes partition quality by integrating combinatorial optimizations and iterative refinement techniques. \texttt{KaHIP} is integrated into our framework via a Julia Bash interface, where the partitioning process is executed as an external call.
    
    % \subsubsection{Graclus --- Spectral and Multilevel Clustering}
    % \texttt{Graclus}\footnote{\url{https://www.cs.utexas.edu/~dml/Software/graclus.html}} is a graph clustering algorithm designed to minimized normalized cut and ratio cut objectives efficiently. It leverages the mathematical equivalence between general cut or association objectives and the weighted kernel $k$-means objective\cite{10.1145/1081870.1081948, 4302760}. By integrating \texttt{Graclus} into our framework, we provide users with a Julia interface allowing for seamless interaction with \texttt{Graclus} while maintaining a consistent workflow for benchmarking and visualization.
    
    % \subsubsection{MDC --- Multilevel Diffusion Clustering}
    % The \texttt{MDC}\footnote{\url{https://github.com/lechekhabm/MDC}\add{! repo needs to be cleaned or removed from the paper}} algorithm leverages diffusion principles to minimize the normalized cut, adds flexibility through a diffusion parameter, and retrieves high-quality partitions in a multilevel fashion without computing eigenpairs\cite{Lechekhab2024MDC}. Comparison with modern multilevel multilevel graph clustering packages reveal that this method can improve the clustering of graphs both in terms of balanced cut criteria and classification accuracy.
% \end{document}